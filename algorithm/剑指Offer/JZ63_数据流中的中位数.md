# JZ63 数据流中的中位数	

## 考点

排序；堆
## LeetCode类似题目

- 295. [数据流中的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/) | [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

## 题目描述

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

## 题干分析

- 数据流：一种动态（流动）的数据，如果使用数组存储，每次新进来一个数据都进行排序的话，效率很低。处理动态数据一般使用的数据结构是栈、队列、二叉树、堆。

## 解题思路

### 解法一：暴力法

直接利用sort排序，按照奇偶分别求出中位数。

- 时间复杂度：O(NlogN)

```js
const data = [];
function Insert(num)
{
    // write code here
    data.push(num);
}
function GetMedian(){
	// write code here
    const length = data.length;
    if (!length) {
        return null;
    }
    data.sort((a , b) => (a - b)); // 避免数据流中的空数据影响数值排序
    if (length & 1) { //此处判断奇偶可用位运算符，提高运算性能
        return data[(length - 1) / 2];
    }
    return (data[length / 2] + data[length / 2 - 1]) / 2;
}
```

>**ATTENTION**
>
>- Javascript sort()方法若没有使用参数，则默认按照字母顺序（字符编码顺序）对数组中的元素进行排序，若想按照其他标准进行排序，则需要提供比较函数：
>
>  ```js
>  data.sort((a, b) => (a - b));	// 升序
>  data.sort((a, b) => (b - a));	// 降序
>  ```

### 解法二：二分查找法

保证数组元素一直是有序的，对新添加的元素通过**二分查找**来插入到正确位置。

- 时间复杂度：O(N)。
  - 二分查找法的时间复杂度为O(logN)，array.splice()方法移动元素的时间复杂度为O(N)，所以综合的时间复杂度为O(N)。

```js
const data = [];
function Insert(num)
{
    // write code here
    if (!data.length) {
        data.push(num);
        return;
    }
    // 二分查找法
    let left = 0, right = data.length - 1;
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        if (data[mid] == num) {
            data.splice(mid, 0, num);
        } else if (data[mid] < num) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    data.splice(left, 0, num);
}
function GetMedian(){
	// write code here
    const length = data.length;
    if (!length) {
        return null;
    }
    if (length & 1) {
        return data[(length - 1) / 2];
    }
    return (data[length / 2] + data[length / 2 - 1]) / 2;
}
```

### 解法三：最大堆+最小堆



```js
TO BE CONTINUED
```



